---
layout: post
title: IA-32保护模式（1）
date: 2017-1-21 10:52
category: "ASM"
---

### 前言
简单介绍如何从实模式进入保护模式，以及相关的知识点。

### 正文
80386是Intel第一款32位的处理器，它支持32位的保护模式，能够以分段（或分页）的形式支持多任务。
在实模式下，用户程序对内存的访问是不加限制的，用户可以访问和修改任意内存单元的数据，然而在多任务的系统中，必须对的程序加以限制，保证一个用户的程序不会影响操作系统或者其他的用户程序或数据，因此需要保护模式。
在保护模式下，所有的用户程序都有自己的段，用户访问内存时，需要段地址和偏移地址（这和实模式下一样），所有的用户的段信息都统一存放在一个叫做**全局描述符表（Global Descriptor Table， GDT）**的表中，而在这个表中的表项称为**段描述符（Segment Descriptor）**，它存储的是一个和段有关的信息，一共8个字节。在进入保护模式之前，必须定义全局描述符表。
全局描述符表可以在内存的任意位置，为了跟踪它，处理器内部存在一个48位的寄存器，称为**全局描述符表寄存器（GDTR）**，其组成如图所示，

![GDTR](/images/ASM/GDTR.png)

其中低16位是边界，说明一个表最大为 $$ 2^{16} $$ 字节，也就是64KB，而一个段描述符占8字节，所以最多可以定义8192个段描述符。高32位表示GDT的基地址，寻址范围是 $$ 2^{32} $$字节。由于必须要在进入保护模式之前的实模式定义GDT，所以最开始的GDT是在1M范围内的。

描述符的格式如下：

![segment_descriptor](/images/ASM/segment_descriptor.png)

段基地址字段制定了段的起始地址，一共32位，在未开启分页时，就是物理地址，应尽量选择16字节对齐的地址作为段基地址。段界限用来限制段的扩展范围，一共20位，访存是通过段基地址加偏移地址组成的，对向高地址扩展的段，例如代码段，段界限决定了偏移量的最大值；对于向低地址扩展的段，例如栈段，段界限决定了偏移量的最大值。段基地址字段和段界限字段的不连续是由于兼容之前的处理器导致的。

G位代表粒度（Granularity），为0时段界限以字节为单位（扩展范围为1B～1MB），若为1时，代表段界限以4KB为单位（扩展范围为4KB～4GB）。

S位用于指定描述符类型，为0时表示为系统段，为1时表示一个代码段或数据段。

DPL表示描述符的特权级（0~3），0为最高级，3为最低级。

P是段存在位（Segment Present），用于指示描述符对应的段是否存在于内存中，0为不在，1为存在。由处理器负责检查，为0时产生一个异常中断。

D/B可以不用管。置1就行。

TYPE字段共4位，其意义如图所示。

| X | E | W | A | 描述符类别 | 含义 |
|---|---|---|---|-----------|--------------------|
| 0 | 0 | 0 | x | 数据 | 只读（向高地址扩展） |
| 0 | 0 | 1 | x | 数据 | 读写（向高地址扩展） |
| 0 | 1 | 0 | x | 数据 | 只读（向低地址扩展） |
| 0 | 1 | 1 | x | 数据 | 读写（向低地址扩展） |

| X | C | R | A | 描述符类别 | 含义 |
|---|---|---|---|-----------|--------------------|
| 1 | 0 | 0 | x | 代码 | 只执行（非依从的代码段） |
| 1 | 0 | 1 | x | 代码 | 执行、读（非依从的代码段） |
| 1 | 1 | 0 | x | 代码 | 只执行（依从的代码段） |
| 1 | 1 | 1 | x | 代码 | 执行、读（依从的代码段） |

X表示是否可以执行，数据是不可执行的，代码才是可执行的。
E表示是否向低地址扩展。
W表是否可写。
C表示是否为特权级依从的，C=0表示非依从的代码段，可以从特权级相同的代码段调用，C=1，可以从低级的代码段中调用。
R表示是否可读。
A表示是否已访问。创建时清零，访问后处理器自动置1。

AVL是由操作系统管理的，处理器并不使用。

### 结尾
关于保护模式的介绍暂时先到这里，下次继续。